const express = require('express');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const { cloudinary } = require('../../utils/cloudinary');
const router = express.Router();

const getHRZone = (hr, maxHr = 190) => {
  const percent = hr / maxHr;
  if (percent < 0.6) return 1;
  if (percent < 0.7) return 2;
  if (percent < 0.8) return 3;
  if (percent < 0.9) return 4;
  return 5;
};

router.post('/fetch-activities', async (req, res) => {
  const { accessToken, userId } = req.body;

  if (!accessToken || !userId) {
    return res.status(400).json({ error: 'Missing accessToken or userId' });
  }

  try {
    const activityRes = await axios.get('https://www.strava.com/api/v3/athlete/activities', {
      headers: { Authorization: `Bearer ${accessToken}` },
      params: { per_page: 50, page: 1 }
    });

    const baseActivities = activityRes.data;

    const detailedActivities = await Promise.all(
      baseActivities.map(async (activity) => {
        try {
          const streamRes = await axios.get(`https://www.strava.com/api/v3/activities/${activity.id}/streams`, {
            headers: { Authorization: `Bearer ${accessToken}` },
            params: { keys: 'heartrate,time' }
          });

          const hrStream = streamRes.data.find(s => s.type === 'heartrate')?.data || [];
          const zoneBuckets = [0, 0, 0, 0, 0];

          for (const hr of hrStream) {
            const zone = getHRZone(hr);
            if (zone >= 1 && zone <= 5) zoneBuckets[zone - 1] += 1;
          }

          const total = zoneBuckets.reduce((a, b) => a + b, 0);
          const zoneDistribution = zoneBuckets.map(z => total ? +(z / total * 100).toFixed(1) : 0);

          return {
            ...activity,
            zoneDistribution, // [Z1%, Z2%, Z3%, Z4%, Z5%]
            hrZoneBuckets: zoneBuckets
          };
        } catch (streamErr) {
          console.warn(`⚠️ Failed to fetch streams for activity ${activity.id}`);
          return activity; // Return raw activity if stream fails
        }
      })
    );

    const fileName = `${userId}_strava_insights_${uuidv4()}.json`;
    const filePath = path.join(__dirname, '../../tmp', fileName);
    fs.mkdirSync(path.join(__dirname, '../../tmp'), { recursive: true });
    fs.writeFileSync(filePath, JSON.stringify(detailedActivities, null, 2));

    const result = await cloudinary.uploader.upload(filePath, {
      resource_type: 'raw',
      folder: `easyathlete/${userId}/strava`,
      public_id: fileName.replace('.json', '')
    });

    fs.unlinkSync(filePath);

    return res.status(200).json({
      message: 'Activities with HR zones stored ✅',
      cloudinaryUrl: result.secure_url
    });
  } catch (error) {
    console.error('❌ Fetch or store error:', error.response?.data || error.message);
    return res.status(500).json({ error: 'Failed to fetch and store activities' });
  }
});

module.exports = router;
