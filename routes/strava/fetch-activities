const express = require('express');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const { cloudinary } = require('../../utils/cloudinary');
const router = express.Router();

const getHRZone = (hr, maxHr = 190) => {
  const percent = hr / maxHr;
  if (percent < 0.6) return 1;
  if (percent < 0.7) return 2;
  if (percent < 0.8) return 3;
  if (percent < 0.9) return 4;
  return 5;
};

router.post('/fetch-activities', async (req, res) => {
  const { accessToken, userId } = req.body;

  if (!accessToken || !userId) {
    return res.status(400).json({ error: 'Missing accessToken or userId' });
  }

  try {
    const activityRes = await axios.get('https://www.strava.com/api/v3/athlete/activities', {
      headers: { Authorization: `Bearer ${accessToken}` },
      params: { per_page: 50, page: 1 }
    });

    const baseActivities = activityRes.data;

    const detailedActivities = await Promise.all(
      baseActivities.map(async (activity) => {
        let zoneDistribution = [];
        let hrZoneBuckets = [];

        try {
          const streamRes = await axios.get(`https://www.strava.com/api/v3/activities/${activity.id}/streams`, {
            headers: { Authorization: `Bearer ${accessToken}` },
            params: { keys: 'heartrate,time' }
          });

          const hrStream = streamRes.data.find(s => s.type === 'heartrate')?.data || [];
          hrZoneBuckets = [0, 0, 0, 0, 0];

          for (const hr of hrStream) {
            const zone = getHRZone(hr);
            if (zone >= 1 && zone <= 5) hrZoneBuckets[zone - 1] += 1;
          }

          const total = hrZoneBuckets.reduce((a, b) => a + b, 0);
          zoneDistribution = hrZoneBuckets.map(z => total ? +(z / total * 100).toFixed(1) : 0);
        } catch (err) {
          console.warn(`⚠️ Failed to fetch streams for activity ${activity.id}`);
        }

        const distanceKm = activity.distance ? activity.distance / 1000 : 0;
        const movingTimeMin = activity.moving_time ? activity.moving_time / 60 : 0;
        const avgHR = activity.average_heartrate || 0;

        const paceMinPerKm = distanceKm ? +(movingTimeMin / distanceKm).toFixed(2) : null;
        const hrEfficiency = avgHR ? +(paceMinPerKm / avgHR).toFixed(4) : null;
        const elevationPerKm = distanceKm ? +(activity.total_elevation_gain / distanceKm).toFixed(2) : null;
        const estimatedLoad = avgHR && movingTimeMin ? +(avgHR * movingTimeMin / 100).toFixed(2) : null;

        return {
          ...activity,
          zoneDistribution,
          hrZoneBuckets,
          distanceKm,
          movingTimeMin,
          paceMinPerKm,
          hrEfficiency,
          elevationPerKm,
          estimatedLoad
        };
      })
    );

    const fileName = `${userId}_strava_insights_${uuidv4()}.json`;
    const filePath = path.join(__dirname, '../../tmp', fileName);
    fs.mkdirSync(path.join(__dirname, '../../tmp'), { recursive: true });
    fs.writeFileSync(filePath, JSON.stringify(detailedActivities, null, 2));

    const result = await cloudinary.uploader.upload(filePath, {
      resource_type: 'raw',
      folder: `easyathlete/${userId}/strava`,
      public_id: fileName.replace('.json', '')
    });

    fs.unlinkSync(filePath);

    return res.status(200).json({
      message: 'Activities enriched and stored ✅',
      cloudinaryUrl: result.secure_url
    });
  } catch (error) {
    console.error('❌ Fetch or store error:', error.response?.data || error.message);
    return res.status(500).json({ error: 'Failed to fetch and store activities' });
  }
});

module.exports = router;
